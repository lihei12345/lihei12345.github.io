<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS, PHP, Android, FE" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="lihei12345">
<meta property="og:url" content="http://lihei12345.github.io/index.html">
<meta property="og:site_name" content="lihei12345">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lihei12345">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://lihei12345.github.io/"/>

  <title> lihei12345 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?1bb7117018d7436631de2a48ea0893c8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lihei12345</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/16/swift-foundation/" itemprop="url">
                  Swift实践初探
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-16T13:04:35+08:00" content="2016-08-16">
              2016-08-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/16/swift-foundation/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/16/swift-foundation/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h1><h2 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h2><h3 id="Swift-Pods"><a href="#Swift-Pods" class="headerlink" title="Swift + Pods"></a>Swift + Pods</h3><p>Cocoapods从0.36开始通过动态库的形式提供对Swift项目的支持。我们只需要在Podfile中注明，<code>use_frameworks!</code>即可，由于需要支持动态库，所以要求项目的最低版本是iOS 8。Pods采用动态库的主要原因是因为目前iOS操作系统中并没有内置Swift的运行时支持库，这种情况下所有包含Swift的代码无法被编译为静态库，Swift的运行时支持都是通过dylib的形式嵌入的。我们可以解压IAP安装包，在 frameworks 目录下，可以看到Swift相关的dylib: </p>
<p><img src="/img/swift-foundation-dylib-screenshot.png" alt=""></p>
<p>参考：</p>
<ul>
<li><a href="https://blog.cocoapods.org/CocoaPods-0.36/" target="_blank" rel="external">https://blog.cocoapods.org/CocoaPods-0.36/</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html" target="_blank" rel="external">https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html</a></li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>大多数第三方库，比如腾讯/微信/微博的SDK都是静态库，虽然这些库提供了Pod的支持，但是在Swift中并没有办法使用。只能把这些第三方库拖入到项目中，然后通过bridge header在项目中使用。比较隐蔽的是腾讯的SDK，虽然也是framework，但是实际上是静态库。</p>
<p>但是不包含静态库的第三方库，比如SDWebImage，却是可以通过Pods直接引用的，Pods会将代码编译为一个动态库，然后集成到App中。在项目中使用的时候，也只需要简简单单通过 <code>import SDWebImage</code> 即可，这里面的编译关系都会通过module map进行映射管理。</p>
<p>目前国外的一些比如Fabric SDK，是提供了动态framework的，可以直接在Pods中使用，国内目前我还没有看到。。。leancloud说是提供了，但是打包的时候会坑死你，老老实实用静态库。</p>
<p>参考:</p>
<ul>
<li><a href="https://forum.leancloud.cn/t/sdk-app-store/4516" target="_blank" rel="external">https://forum.leancloud.cn/t/sdk-app-store/4516</a></li>
<li><a href="https://forum.leancloud.cn/t/invalid-provisioning-profile/3947" target="_blank" rel="external">https://forum.leancloud.cn/t/invalid-provisioning-profile/3947</a></li>
<li><a href="https://fabric.io/kits/ios/crashlytics/install" target="_blank" rel="external">https://fabric.io/kits/ios/crashlytics/install</a></li>
</ul>
<h3 id="关于modules"><a href="#关于modules" class="headerlink" title="关于modules"></a>关于modules</h3><p><code>Swift’s access control model is based on the concept of modules and source files.</code></p>
<p>代码的访问权限控制在开发中是一个非常重要的手段，我们需要隐藏实现细节，只暴露一些特定的interface给特定的调用者，比如Java中的 public/private/protected。在Swift中，访问权限的控制是基于modules和源文件的，public/internal/private。源文件较为容易理解，module则是比较含糊的概念，官方文档中的解释如下：</p>
<p><code>A module is a single unit of code distribution—a framework or application that is built and shipped as a single unit and that can be imported by another module with Swift’s import keyword.</code></p>
<p>具体来说，对用到Xcode中就是编译target：<code>Each build target (such as an app bundle or framework) in Xcode is treated as a separate module in Swift.</code></p>
<p>而这个module的概念实际上来源于<strong>clang module</strong>，在2012年由Apple工程师提出的概念，用于把传统的C/C++中的include进行简化：<code>Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library.</code></p>
<p>通过这个方式，Swift中引用其他类库的时候，只需要使用import即可，不需要再包含一大堆头文件。如果在一个module内部，编译器会自动处理所有的引用关系，不需要再像OC中引用一大堆繁琐的头文件。在Swift 3.0中，又引入了package manager，跟node/golang中的依赖管理非常类似，但是基本原理应该也是基于module。</p>
<p>参考：</p>
<ul>
<li><a href="http://clang.llvm.org/docs/Modules.html" target="_blank" rel="external">http://clang.llvm.org/docs/Modules.html</a></li>
<li><a href="http://andelf.github.io/blog/2014/06/19/modules-for-swift/" target="_blank" rel="external">http://andelf.github.io/blog/2014/06/19/modules-for-swift/</a></li>
<li><a href="https://spin.atomicobject.com/2015/02/23/c-libraries-swift/" target="_blank" rel="external">https://spin.atomicobject.com/2015/02/23/c-libraries-swift/</a></li>
<li><a href="http://nsomar.com/modular-framework-creating-and-using-them/" target="_blank" rel="external">http://nsomar.com/modular-framework-creating-and-using-them/</a></li>
<li><a href="http://adriansampson.net/blog/llvm.html" target="_blank" rel="external">http://adriansampson.net/blog/llvm.html</a></li>
<li><a href="http://blog.csdn.net/column/details/xf-llvm.html" target="_blank" rel="external">http://blog.csdn.net/column/details/xf-llvm.html</a></li>
<li><a href="http://swift.gg/2016/01/13/swift-ubuntu-x11-window-app/" target="_blank" rel="external">http://swift.gg/2016/01/13/swift-ubuntu-x11-window-app/</a></li>
</ul>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>目前开源的较为流行的图片框架包括SDWebImage和Kingfisher，大致对比了一下SDWebImage与Kingfisher的源代码，发现二者的实现思路基本一致，Kingfisher某种程度上来说是SDWebImage的Swift版本。二者共有的特性:</p>
<ul>
<li>通过category机制对业务提供API</li>
<li>二级缓存机制，memory缓存使用NSCache；disk缓存使用url MD5之后作为key缓存</li>
<li>网络请求使用NSURLSession</li>
<li>后台线程进行图片解码</li>
<li>所有操作异步化，包括下载，缓存管理，解码</li>
<li>支持GIF</li>
<li>缓存使用serial queue实现</li>
</ul>
<p>不同点：</p>
<ul>
<li>下载队列，SDWebImage通过NSOperation进行管理，最大并发请求数为6；Kingfisher没有相关控制</li>
<li>图片下载cancel机制，需要手工调用。这个在快速滑动的列表中，是个非常有用的机制。同时对于偶尔某些超大的图片，这个机制也非常有用；请求数量过多会占用过多的端口和系统资源，尽量减少并发的请求数是非常有意义的。</li>
<li>Kingfisher不支持WebP</li>
<li>Kingfisher业务开发调用和交互更加友好，配置灵活，例如支持加载完毕的动画效果，延迟加载</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>OC环境下一般都是用AFNetworking，针对Swift，AF的开发者又开发了Alamofire用来取代AF。AF 3.0与Alamofire本身都是基于NSURLSession开发，虽然相对于AF2.0而言代码量减少了很多，但是读起来我自己感觉并不AF2.0结构清晰，AF2.0对runloop和NSOperation的使用，让整个框架变得非常易读。但Alamofire相对AF3.0而言，无论是API还是内部代码，都要更加清晰，这要感谢Swift的语法。比如枚举，extension+protocol都让代码更加容易阅读和维护。</p>
<p>还有一个更重要的地方，Alamofire跟RxSwift的结合非常容易实现，并且会让请求更加容易控制，几乎不需要额外的封装，就可以作为整个项目网络架构存在。</p>
<p>参考：</p>
<ul>
<li><a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="external">https://github.com/Alamofire/Alamofire</a></li>
<li><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">https://github.com/AFNetworking/AFNetworking</a></li>
</ul>
<h2 id="FRP"><a href="#FRP" class="headerlink" title="FRP"></a>FRP</h2><h3 id="RxSwift-or-RAC"><a href="#RxSwift-or-RAC" class="headerlink" title="RxSwift or RAC?"></a>RxSwift or RAC?</h3><p>最开始接触FRP是通过RAC来接触的，但是这个过程相当痛苦，我个人的理解主要原因是RAC并没有完全遵循Rx的理念，发明了Signal这个概念，导致整个学习曲线非常陡。再加上OC的语法限制，当使用非常多高阶函数处理signal时，代码的书写和阅读都非常困难，Swift回归正常的调用语法之后，链式调用让代码读起来感觉舒服很多。</p>
<p>关于ReactiveX，官方网站上的解释是，<code>ReactiveX is a combination of the best ideas from
the Observer pattern, the Iterator pattern, and functional programming</code>。ReactiveX是观察者设计模式，迭代器设计模式，和函数式编程的结合，理解这个更加有助于我们更好使用整个框架。如果更多的学习资料和高阶函数的数据流示意可以参考Rx的官方网站：<a href="http://reactivex.io/" target="_blank" rel="external">http://reactivex.io/</a>。</p>
<p>关于RX的学习资料，我目前看到最好资料是官方网站的几篇文章和<code>RxJava Essentials</code>，这本书上给出的关于FRP的解释我认为是我见过最清晰和容易理解的：<code>Reactive programming is a programming paradigm based on the concept of an asynchronous data flow. A data flow is like a river: it can be observed, filtered, manipulated, or merged with a second flow to create a new flow for a new consumer.</code>。Rx为什么好用，看了这本书和官方网站上的文章之后，我觉得有了一个比较直观的解释。简单来说，通过Rx，我们可以使用类似Iterator(例如数组，集合)的操作方式，来处理类似网络请求和UI事件这样的状态，将事件(例如网络请求)的处理简化到跟常量一样容易处理。</p>
<p>相对于RAC，Rx概念更加清晰。data flow类似：<strong>Observables -&gt; Operator -&gt; Observers</strong>，Observables生产实体，Operator进行变换，Observers消费实体。数据流的上游是Observables，中间经过进过Operator变换产生新的Observables，直到到达下游Observers。还有一个比较特殊的存在，<strong>Subject</strong>，既是Observables又是Observers。</p>
<p>具体实现来说，在Swift中，我们使用的时候一般都是通过closure获取数据流，比如onNext()，Observers则被RxSwift实现进行了隐藏，具体实现时这些传入的closure最终会被转换为<code>AnonymousObserver</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">reloadData</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> disposable != <span class="literal">nil</span> &#123;</div><div class="line">        disposable?.dispose()</div><div class="line">        disposable = <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    disposable = viewModel</div><div class="line">        .updateData()</div><div class="line">        .doOnError &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] error <span class="keyword">in</span></div><div class="line">            <span class="type">JLToast</span>.makeText(<span class="string">"网络数据异常，请下拉重试!"</span>).show()</div><div class="line">            <span class="keyword">self</span>?.refresher.stopLoad()</div><div class="line">        &#125;</div><div class="line">        .doOnCompleted &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></div><div class="line">            <span class="keyword">self</span>?.refresher.stopLoad()</div><div class="line">        &#125;</div><div class="line">        .subscribe()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结一下，在Swift中，FRP我认为RxSwift是比较占优势的：</p>
<ul>
<li>ReactiveX的文档相当全面，并且有各种Operator示意图用于帮助理解</li>
<li>RxSwift在整体概念上要比RAC清晰不少</li>
<li>ReactiveX的思想是跨平台的，学习其他语言的基本语法之后，可以做到 “learn once, write everywhere”，这个非常有诱惑力。比如RxJS/RxJava/Rx.NET/Rx.Scala/RxCpp。</li>
</ul>
<h3 id="Hot-vs-Cold-amp-Side-Effect"><a href="#Hot-vs-Cold-amp-Side-Effect" class="headerlink" title="Hot vs Cold &amp; Side Effect"></a>Hot vs Cold &amp; Side Effect</h3><p>从概念上来说，hot observable与cold observable挺好理解的。我一直比较困惑的是在RxSwift使用的过程中，到底哪些是hot的哪些是cold的。一般来说，我们使用Observable.create创建的Observable，即AnonymousObservable，都是cold observable，只有被subscribe的时候才开始emitting items；hot observable，一个比较典型的例子是Variable，无论是否被subscribe，在value发生变化的时候，都会emitting items。</p>
<p>所以一般来说，我们通过自己创建的Observable来处理状态的时候，面对的都是cold observable。RxSwift中这个概念在实现上没有跟RAC 4.0一样做区分，在使用的过程中，需要根据实际情况注意。</p>
<p>关于Side Effect，简单来说，我们使用Observable.create创建Observable时会传入一个block，这个block在observable被subscribe的时候会被执行，这个就叫做side effect，所以一般来说只有cold observable才会有side effect。这个地方如果不注意，会带来一些意想不到的状况。比如说我们使用Observable封装HTTP请求时，每次这个Observable被subscribe，都会触发一次HTTP请求，所以如果被多次subscribe的话，会导致多次网络请求。无论RAC或者RxSwift都会有这个问题，解决方式也都基本一样，使用<a href="http://reactivex.io/documentation/subject.html" target="_blank" rel="external">subject</a>进行multicast。</p>
<p>参考：</p>
<ul>
<li><a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/HotAndColdObservables.md" target="_blank" rel="external">https://github.com/ReactiveX/RxSwift/blob/master/Documentation/HotAndColdObservables.md</a></li>
<li><a href="http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-3.html" target="_blank" rel="external">http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-3.html</a></li>
<li><a href="http://www.introtorx.com/content/v1.0.10621.0/14_HotAndColdObservables.html" target="_blank" rel="external">http://www.introtorx.com/content/v1.0.10621.0/14_HotAndColdObservables.html</a></li>
<li><a href="https://www.raywenderlich.com/126522/reactivecocoa-vs-rxswift" target="_blank" rel="external">https://www.raywenderlich.com/126522/reactivecocoa-vs-rxswift</a></li>
</ul>
<h2 id="其他框架"><a href="#其他框架" class="headerlink" title="其他框架"></a>其他框架</h2><h3 id="Mantle"><a href="#Mantle" class="headerlink" title="Mantle"></a>Mantle</h3><p>OC中常用的框架是Mantle，Mantle的核心代码我之前越过一遍，从工程的角度讲非常不错，可以参考我之前的博客：<a href="http://blog.csdn.net/colorapp/article/details/50277317" target="_blank" rel="external">http://blog.csdn.net/colorapp/article/details/50277317</a>。Mantle的实现核心是通过runtime获取属性列表，然后通过 KVC + try/catch 设置value，但是由于Swift是静态语言，这些hack技术都讲无法使用。在Swift中的ORM框架一般都是通过操作符重载来实现ORM过程的简化，我并没有阅读过这种类型框架的源代码，但是就使用感觉而言，并不比Mantle复杂，甚至重载之后的操作符用起来比Mantle中的字典更加安全和可读性更高。</p>
<h3 id="Masonry"><a href="#Masonry" class="headerlink" title="Masonry"></a>Masonry</h3><p>还有另外一个经常使用的框架就是Masonry，之前也阅读过它的源代码，参考之前的博客，<a href="http://blog.csdn.net/colorapp/article/details/45030163" target="_blank" rel="external">http://blog.csdn.net/colorapp/article/details/45030163</a>。我认为它的核心是利用Dot Notation实现的链式调用以及巧妙的DSL，极大简化了Auto Layout的开发。Swift中，这个库的作者也开发对应的实现：SnapKit。SnapKit的使用与Masonry的差别并不大，使用起来并不会有任何陌生。源代码暂时还没有阅读，不好对内部的实现进行对比。</p>
<p>无论是Masonry还是SnapKit，都有一个非常需要注意的地方 <code>update constraints</code>和<code>remake constraints</code>的区别，以及update到底update了什么，什么时候可以用update什么时候不可以。</p>
<p>update constraints首先会比对两个constraints是否相等，如果相等，只更新NSLayoutConstraint的constant字段。不相等会重新添加新的constraints。所以当constraints可能根据交互或者内容的时候，使用constraints需要谨慎，很可能就造成约束冲突。这部分查看Masonry的<code>MASViewConstraint</code>的<code>- (void)install</code>和<code>- (MASLayoutConstraint *)layoutConstraintSimilarTo:(MASLayoutConstraint *)layoutConstraint</code>方法。</p>
<h1 id="业务开发"><a href="#业务开发" class="headerlink" title="业务开发"></a>业务开发</h1><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><ul>
<li>在Objective-C开发中，我个人比较推荐单文件单类，因为类的声明是两部分，这样可以让代码的可读性更高，并且可能会造成比如说命名冲突；</li>
<li>而在Swift中，代码访问控制更加高级，将多个类组织在一个文件中，代码阅读起来会更加方便一些，并且类名与文件名可以不需要相同</li>
<li>同时，可以利用Swift的Module和Pods的Dynamic framework的实现，将项目更合理进行架构划分，让模块关系变得清晰</li>
</ul>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>庞大的业务Controller一直是业务开发过程中难以解决的痛点问题。有几种通用的手段：</p>
<ul>
<li>MVCS或者MVVM，说一下我自己的理解，两者的共同点都是将数据逻辑从VC中抽取到单独的类中，比如Service或者MVVM，区别只是数据流的方向不一样</li>
<li>抽象较为通用的业务逻辑服务化，具体来说就是抽象为较为独立的逻辑为Service，VC直接调用这些Service暴露的接口即可实现某种逻辑，比如账户/分享/定位/数据持久化等</li>
<li>基于网络框架提供更高层次的封装，为业务层提供更加简洁的API，例如ORM框架/网络框架的二次封装/Masonry这种UI框架</li>
<li>抽取较为通用的View作为项目通用的UI库，例如上下拉组件/Alert组件/ViewPager/下拉框等基本组件，甚至可以解耦发布为pod私有库</li>
<li>维护项目中较为通用的工具类，这个在iOS中有个非常有效的技术手段，Objective-C中的category，Swift中的extension。例如：UIImage的基本处理(缩放/截图)/UIView相关/JSON的处理等。这个积累到一定量之后，能大大提高开发效率以及代码的可读性</li>
</ul>
<p>在Swift中，可以合理利用extension将VC的代码模块化分割，将代码更加合理分布。例如，Eureka的FormViewController的分割：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FormViewController</span> : <span class="title">UITableViewDataSource</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//MARK: UITableViewDataSource</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">numberOfSectionsInTableView</span><span class="params">(tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> form.<span class="built_in">count</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> form[section].<span class="built_in">count</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</div><div class="line">    	form[indexPath].updateCell()</div><div class="line">        <span class="keyword">return</span> form[indexPath].baseCell</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, titleForHeaderInSection section: Int)</span></span> -&gt; <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">return</span> form[section].header?.title</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, titleForFooterInSection section: Int)</span></span> -&gt; <span class="type">String</span>? &#123;</div><div class="line">        <span class="keyword">return</span> form[section].footer?.title</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于更多的代码实践，由于我目前只是业余时间写了两周Swift，并没有更好的实践可以分享，这部分刚开始，应该来说，best practice还都处于总结中。</p>
<h2 id="MVVM-MVP-Redux-Protocol-Oriented-Programming"><a href="#MVVM-MVP-Redux-Protocol-Oriented-Programming" class="headerlink" title="MVVM/MVP/Redux/Protocol-Oriented Programming"></a>MVVM/MVP/Redux/Protocol-Oriented Programming</h2><p>在Objective-C开发中，外卖通过广泛使用 MVVM + RAC 来对膨胀的业务逻辑进行控制，效果相当不错，开发效率和代码质量都有不错的提升。得益于Swift的现代语法，我们有了更多的选择，通过这些编程范式，可以让复杂的业务逻辑开发得以简化。MVVM/MVP这里不多说，可以参考的博客有很多，大家应该都有不少接触，下面介绍一下Redux和面向协议编程。</p>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>FB创造React时提出了Flux数据流概念，意在通过单向数据流和不可变状态简化前端状态的管理，但是FB本身对Flux的实现过于复杂，反而是第三方基于Flux提出的Redux，工程上来说更加简单实用。Redux既可以认为是Flux的具体实现也可以认为是Flux的简化，在实际的 React.js/ReactNative 项目中，大多数都是采用Redux进行日常开发。此外，Redux的文档质量相当高，对前端开发的各种理念都有一些挺不错的总结，可以参考我之前的学习笔记：<a href="http://blog.csdn.net/colorapp/article/details/50256913" target="_blank" rel="external">Redux学习笔记</a>。国外的工程师基于Redux实现了Swift版本<a href="https://github.com/ReSwift/ReSwift" target="_blank" rel="external">ReSwift</a>。我目前还没有实际中研究过ReSwift，但是就我之前对Redux的研究而言，发现Redux对于客户端开发并不适用，客户端大量的交互对Redux来说是个噩梦，大量的非模态交互，可能导致很多复杂的数据问题，比如要求请求随时可cancel。</p>
<h3 id="Protocol-Oriented-Programming"><a href="#Protocol-Oriented-Programming" class="headerlink" title="Protocol-Oriented Programming"></a>Protocol-Oriented Programming</h3><p>Protocol-Oriented Programming 是Apple在WWDC 2015发布Swift 2.0的时候推荐的编程范式，可以充分发挥Swift的语法优势，Apple认为这个是Swift的核心。详细大家可以看WWDC上相关的视频，<a href="https://developer.apple.com/videos/play/wwdc2015/408/" target="_blank" rel="external">Protocol-Oriented Programming in Swift</a>。这里给大家简单介绍一下，我个人认为当前前端的开发效率的不足，主要的问题是相对后端来说，前端领域的状态比较复杂，很难抽象提取，而Apple推荐面向协议编程也是为了解决iOS开发效率的问题。传统OOP是有缺陷和不足的，下面这些来自 <a href="https://gist.github.com/rbobbins/de5c75cf709f0109ee95" target="_blank" rel="external">https://gist.github.com/rbobbins/de5c75cf709f0109ee95</a> :</p>
<ul>
<li>Automatic sharing. Two classes can have a reference to the same data, which causes bugs. You try to copy things to stop these bugs, which slows the app down, which causes race conditions, so you add locks, which slows things down more, and then you have deadlock and more complexity. BUGS! This is all due to implicit sharing of mutable state. Swift collections are all value types, so these issues don’t happen</li>
<li>Inheritance is too intrusive. You can only have 1 super class. You end up bloating your super class. Super classes might have stored properties, which bloat it. Initialization is a pain. You don’t want to break super class invariants. You have to know what to over ride, and how. This is why we use delegation in Cocoa</li>
<li>Lost type relationships. You can’t count on subclasses to implement some method, e.g:</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ordered</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">precedes</span><span class="params">(other: Ordered)</span></span> -&gt; <span class="type">Bool</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"implement me"</span>) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span>: <span class="title">Ordered</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> value: <span class="type">Int</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">precedes</span><span class="params">(other: Ordered)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> value &lt; other.value <span class="comment">//THIS IS THE PROBLEM! WHAT TYPE IS ORDRED?! Does it have a value? Let's force type cast it</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我这里只做一个大概的介绍，详细的资料大家可以参考下面的参考资料。举个让我印象比较深刻的用法，Swift中的 protocol + extension 结合在一起，甚至可以实现类似其他语言中的traits特性 (比如最好的编程语言<strong>PHP</strong>)，将代码的复用颗粒度缩小到某一部分逻辑抽象，不再受限于类继承。这里举个不一定特别合适的例子，比如，飞行这个特性，鸟可以飞行，飞机也能飞行，他们这部分逻辑是能够进行抽象复用的，而鸟和飞机之间却很难抽象到一个基类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义protocol</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Flyable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> speed: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 为protocol通过extension添加方法实现</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Flyable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(<span class="keyword">self</span>)</span> fly: <span class="subst">\(speed)</span> km/h"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 复用飞行逻辑</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>: <span class="title">Flyable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> speed: <span class="type">Double</span> = <span class="number">5</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span>: <span class="title">Flyable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> speed: <span class="type">Double</span> = <span class="number">500</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> bird = <span class="type">Bird</span>()</div><div class="line">    bird.fly()</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> plane = <span class="type">Plane</span>()</div><div class="line">    plane.fly()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">playswift.Bird fly: 5.0 km/h</div><div class="line">playswift.Plane fly: 500.0 km/h</div></pre></td></tr></table></figure>
<p>举个更加实际的例子，错误页面的统一处理，来自 <a href="http://krakendev.io/blog/subclassing-can-suck-and-heres-why" target="_blank" rel="external">http://krakendev.io/blog/subclassing-can-suck-and-heres-why</a> ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ErrorPopoverRenderer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">presentError</span><span class="params">(message message: String)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ErrorPopoverRenderer</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">presentError</span><span class="params">(message message: String)</span></span> &#123;</div><div class="line">        <span class="comment">//Add default implementation here and provide default values to your Error View.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomViewController</span>: <span class="title">UIViewController</span>, <span class="title">ErrorPopoverRenderer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">failedToEatHuman</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">//…</span></div><div class="line">        <span class="comment">//Throw error because the Kraken sucks at eating Humans today.</span></div><div class="line">        presentError(message: <span class="string">"Oh noes! I didn't get to eat the Human!"</span>) <span class="comment">//Woohoo! We can provide whatever parameters we want, or no parameters at all!</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2015/408/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2015/408/</a></li>
<li><a href="https://www.raywenderlich.com/109156/introducing-protocol-oriented-programming-in-swift-2" target="_blank" rel="external">https://www.raywenderlich.com/109156/introducing-protocol-oriented-programming-in-swift-2</a></li>
<li><a href="http://krakendev.io/blog/subclassing-can-suck-and-heres-why" target="_blank" rel="external">http://krakendev.io/blog/subclassing-can-suck-and-heres-why</a></li>
<li><a href="https://gist.github.com/rbobbins/de5c75cf709f0109ee95" target="_blank" rel="external">https://gist.github.com/rbobbins/de5c75cf709f0109ee95</a></li>
<li><a href="http://matthewpalmer.net/blog/2015/08/30/protocol-oriented-programming-in-the-real-world/" target="_blank" rel="external">http://matthewpalmer.net/blog/2015/08/30/protocol-oriented-programming-in-the-real-world/</a></li>
</ul>
<h1 id="转变思维"><a href="#转变思维" class="headerlink" title="转变思维"></a>转变思维</h1><ul>
<li>Protocol</li>
<li>泛型</li>
<li>Extension</li>
<li>Enum</li>
<li>Optional</li>
<li>错误处理</li>
<li>Swift的class与NSObject</li>
<li>避免OC的黑魔法</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="http://iosre.com/t/rxswift-runtime-oc-ios/3727" target="_blank" rel="external">http://iosre.com/t/rxswift-runtime-oc-ios/3727</a></li>
</ul>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><ul>
<li>编译 &amp; 打包 速度</li>
<li>Xcode莫名其妙crash</li>
<li>安装包大小</li>
<li>语法变化太快，不能做到向下兼容</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/15/hexo-blog-setup/" itemprop="url">
                  Hexo博客搭建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-15T13:51:26+08:00" content="2016-07-15">
              2016-07-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/15/hexo-blog-setup/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/15/hexo-blog-setup/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>WordPress搭建博客的方式不太适应技术记录与分享，搭建复杂，需要自己的主机进行Host。而一般的技术博客，只需要静态网页就能满足需求。目前比较流行的是Hexo与Jekyll，后者的搭建过于复杂，所以目前Hexo较为流行。目前几家做的比较好的团队技术博客：</p>
<ul>
<li><a href="http://tech.meituan.com/" target="_blank" rel="external">美团点评技术团队</a></li>
<li>微信移动客户端开发团队: <strong>WeMobileDev</strong></li>
<li><a href="http://wereadteam.github.io/" target="_blank" rel="external">微信阅读团队技术博客</a></li>
<li><a href="http://dev.qq.com/" target="_blank" rel="external">腾讯Bugly</a>，微信公众号: <strong>腾讯Bugly</strong></li>
<li><a href="http://baiduhidevios.github.io/" target="_blank" rel="external">百度Hi技术周报</a></li>
<li><a href="http://eleme.io/mobilists/" target="_blank" rel="external">饿了么用户端技术博客</a></li>
<li><a href="http://mobilefrontier.github.io/" target="_blank" rel="external">移动开发前线</a></li>
<li>微信公众号：<strong>QQ空间终端开发团队</strong></li>
</ul>
<h1 id="github-io"><a href="#github-io" class="headerlink" title="github.io"></a>github.io</h1><p>首先，创建github.io，用来host我们要生成的静态博客。创建的方式非常简单，参考：<a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a></p>
<h1 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h1><p>Hexo是基于Node.js构建的，使用npm进行安装管理非常便捷：<a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a>。</p>
<p>整体的安装与使用官方文档讲解的非常清晰，参考文档能快速完成搭建工作。在搭建的过程中，有几点需要注意一下：</p>
<h1 id="1-分类与标签"><a href="#1-分类与标签" class="headerlink" title="1. 分类与标签"></a>1. 分类与标签</h1><p>这点与WP这种动态网站不同，不需要额外创建分类与标签，只需要在post的文档顶部配置 <code>categories</code> 与 <code>tags</code> 即可，hexo在构建静态网页的时候，会自动进行提取归类。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: Modern PHP -- 读书笔记</div><div class="line">date: 2016-07-14 18:40:28</div><div class="line">tags:</div><div class="line">    - PHP</div><div class="line">categories:</div><div class="line">    - Jason</div><div class="line">---</div></pre></td></tr></table></figure></p>
<p>对于团队技术博客而言，categories可以设置为团队成员的名称，这样就能比较好归纳。</p>
<h1 id="2-主题"><a href="#2-主题" class="headerlink" title="2. 主题"></a>2. 主题</h1><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>我采用的主题与微信阅读团队的一致，Next Mist主题。具体的搭建过程可以参考：</p>
<ul>
<li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a></li>
<li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">http://theme-next.iissnan.com/getting-started.html</a></li>
</ul>
<h2 id="评论设置"><a href="#评论设置" class="headerlink" title="评论设置"></a>评论设置</h2><p>采用disqus评论系统，设置过程也非常简单，可以参考：<a href="https://github.com/iissnan/hexo-theme-next/wiki/%E8%AE%BE%E7%BD%AE%E5%A4%9A%E8%AF%B4-DISQUS" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next/wiki/%E8%AE%BE%E7%BD%AE%E5%A4%9A%E8%AF%B4-DISQUS</a></p>
<h1 id="3-部署"><a href="#3-部署" class="headerlink" title="3.部署"></a>3.部署</h1><p>我才用的部署方式git，配置与使用都非常简单，一行代码就能编译然后部署博客静态网页：<br><a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/deployment.html</a></p>
<p>这里有个比较奇怪的问题，在修改post之后，deploy始终无法更新，总是提示 “nothing to commit…”，解决方式：<a href="https://github.com/hexojs/hexo/issues/67" target="_blank" rel="external">https://github.com/hexojs/hexo/issues/67</a>。调用下面三行命令清除缓存再部署：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.rm -rf .deploy</div><div class="line">2.hexo generater</div><div class="line">3.hexo deploy</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/14/modern-php-one/" itemprop="url">
                  Modern PHP -- 读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-14T18:40:28+08:00" content="2016-07-14">
              2016-07-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Server/" itemprop="url" rel="index">
                    <span itemprop="name">Server</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/14/modern-php-one/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/14/modern-php-one/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于PHP，大家的误解比较多，但其实现代PHP是一门无论开发效率还是执行效率都相当高的编程语言。关于现代PHP的各方面特性，大家可以参考<code>&lt;Modern PHP&gt;</code>作者之前写的 <strong><a href="http://www.phptherightway.com/" target="_blank" rel="external">PHP the right way</a></strong>，中文翻译：<strong><a href="http://laravel-china.github.io/php-the-right-way/" target="_blank" rel="external">PHP之道</a></strong>。同时，作者也是比较流行的PHP框架 –  <strong><a href="http://www.slimframework.com/" target="_blank" rel="external">Slim</a></strong> 的开发者。所以这本书非常值得已读，甚至你只需要懂一些OOP的概念即可，并不需要你懂PHP开发。</p>
<h1 id="Part-1-Language-Feature"><a href="#Part-1-Language-Feature" class="headerlink" title="Part 1. Language Feature"></a>Part 1. Language Feature</h1><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><h3 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h3><p>PHP命名空间使用 “\” 字符来分割sumnamespaces。与操作系统的物理文件系统不同，PHP命名空间是一个抽象概念，不必跟文件目录一一对应。大多数PHP Components都是根据PSR-4 autoloader standard来组织subnamespaces与文件目录的映射关系的。</p>
<p>从技术上来说，namespaces仅仅是一个PHP语言的符号，PHP解释器使用这个符号来作为一组classes/interfaces/functions/constants集合的前缀，仅此而已。</p>
<p><code>Namespaces are important because they let us create sandboxed code that works alongside other developer&#39;s code. This is the cornerstone concept of the modern PHP component ecosystem.</code></p>
<h4 id="Helpful-Tips"><a href="#Helpful-Tips" class="headerlink" title="Helpful Tips"></a>Helpful Tips</h4><p><strong>1. Multiple imports</strong><br>bad:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">use</span> <span class="title">Symfony</span>\<span class="title">Component</span>\<span class="title">HttpFoundation</span>\<span class="title">Request</span>,</div><div class="line">        <span class="title">Symfony</span>\<span class="title">Component</span>\<span class="title">HttpFoundation</span>\<span class="title">Response</span>,</div><div class="line">        <span class="title">Symfony</span>\<span class="title">Component</span>\<span class="title">HttpFoundation</span>\<span class="title">Cookie</span>;</div></pre></td></tr></table></figure></p>
<p>good:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">use</span> <span class="title">Symfony</span>\<span class="title">Component</span>\<span class="title">HttpFoundation</span>\<span class="title">Request</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">Symfony</span>\<span class="title">Component</span>\<span class="title">HttpFoundation</span>\<span class="title">Response</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">Symfony</span>\<span class="title">Component</span>\<span class="title">HttpFoundation</span>\<span class="title">Cookie</span>;</div></pre></td></tr></table></figure></p>
<p><strong>2. One class per file</strong><br>这点不用多说，每个文件应该只有一个类！</p>
<p><strong>3.Global namespace</strong><br>如果我们引用一个没有命名空间的class/interface/function/constant，PHP会首先假设这个class/interface/function/constant在当前的命名空间中。如果在当前命名空间中没有找到，PHP才会开始resolve。而对于那些没有没有命名空间的代码，PHP认为他们存在于global namespace。</p>
<p><strong>PSR-4</strong></p>
<h3 id="Code-to-an-interface"><a href="#Code-to-an-interface" class="headerlink" title="Code to an interface"></a>Code to an interface</h3><p><code>An interface is a contract between tow PHP objects that lets one object depend not on what another object is but, instead, on what another can do.</code></p>
<h3 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h3><p><code>A trait is a partial class implementation(i.e., constants, properties, and methods) that can be mixed into one or more existing PHP classes. Traits work double duty: they say what a class can do (like an interface), and they provide a modular implementation (like class).</code></p>
<p>相对Android开发，我最喜欢的iOS中一个特性就是category，PHP的trait就是有点类似于category，不过还是不太一样的：</p>
<ol>
<li>OC只能针对特定的类进行扩展，而PHP的trait可以将代码单元注入到任意的不相关的类中；</li>
<li>同时OC中的category并不能直接实现属性的扩展，而PHP的trait则能实现常量，属性，以及方法；</li>
<li>PHP的trait跟OC的category根本上来说用途是不一样的，OC是对现存类直接扩展，不需要继承实现类。而PHP的trait需要在类的定义中使用 <code>use</code> 来明确。</li>
</ol>
<p>跟class和interface的定义一样，<strong>on trait per file</strong>。</p>
<h3 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h3><p><code>Generators are easy to create because they are just PHP functions that use the yield keyword one or more times. Unlike regular PHP functions, generators never return a value. They only yield values.</code></p>
<p>这个概念并不陌生，Python包括Swift都有这个特性，可以用在对大量数据的迭代中，动态去获取数据，而不是一次性生成，避免内存的浪费。</p>
<p>在每次迭代的过程中，PHP都会让Generator实例计算和提供下一个迭代值。在这个过程中，当generator执行到yield value的时候，generator会暂停它的内部状态的执行。只有generator被要求提供下一个迭代值的时候，它才会继续它的内部状态的执行。generator就这样反复pasuing 和 resuming，直到到达generator的函数定义的尾部或empty的时候，generator才会结束执行。</p>
<p><code>Generators are a tradeoff between versatility and simplicity. Generators are forward-only iterators.</code></p>
<h3 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h3><p><code>A closure is a function that encapsulates its surrounding state at the time it is created. The encapsulated state exists inside the closure even when the closure lives after it original environment ceases to exist.</code></p>
<p>这里的闭包是指Closure和Anonymous functions。上面是作者对于闭包的解释，感觉非常准确，比我看到的大多数解释都要简单清晰。闭包在日常业务开发中非常有用，可以非常方便替换我们经常需要用到的delegate设计模式，不需要再去定义一个interface，然后再实现这个interface，再把对应的对象指针传递过去。而是通过Closure，只需要简简单单传递一段代码即可，这个极大简化了日常业务开发。所以目前iOS开发中，大家通常都会使用block来代替delegate设计模式。</p>
<p>PHP Closure or Anonymous function 跟PHP function的定义语法是一样的，但是实际上 Closure 的背后是Closure class的实例，所以Closure被认为是first-class value types。</p>
<p><strong><em>Attach State</em></strong> : PHP的Closure不会automatically enclose application state，不像JavaScript/OC那样会capture作用域之外的变量。而是，<code>you must manually attach state to a PHP closure with the closure object&#39;s bindTo() method or the use keyword.</code></p>
<p>需要注意的是，PHP closures是objects。而我们之所以能让一个closure 实例变量进行调用，是因为这个对象实现 <code>__invoke()</code> magic method，当我们在closure实例变量后面跟着一个 <code>()</code> 的时候，closure实例变量就会寻找并且调用<code>__invoke()</code> 方法，例如 <code>$closure(&quot;Jason&quot;)</code>。</p>
<p>同样，由于PHP closure是objects。所以，在closure内部我们也可以通过 <code>$this</code> 访问closure的各种内部状态，但是这个状态是非常boring。同时，closure的<code>bindTo()</code>方法可以有一些非常有趣的特殊用法，<code>This method lets us bind a Closure object&#39;s internal state to a different object. The bindTo() method accepts an important second argument that specifies the PHP class of the object to which the closure is bound.This lets the closure access protected and private member variables of the object to which it is bound.</code>。这个用法有点类似JavaScript的bind方法，可以改变Closure object的 $this 指针指向。</p>
<p>bindTo()这个有趣的用法，经常各种PHP框架的路由所采用，例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?</span> php</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">protected</span> $routes = <span class="keyword">array</span>();</div><div class="line">    <span class="keyword">protected</span> $responseStatus = <span class="string">'200 OK'</span>;</div><div class="line">    <span class="keyword">protected</span> $responseContentType =<span class="string">'text/html'</span>;</div><div class="line">    <span class="keyword">protected</span> $responseBody = <span class="string">'Hello world'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addRoute</span><span class="params">($routePath, $routeCallback)</span></span></div><div class="line">    &#123;</div><div class="line">    	<span class="comment">// 将Closure bind到App类上</span></div><div class="line">    	<span class="keyword">$this</span>-&gt;routes[$routePath] = $routeCallback-&gt;bindTo(<span class="keyword">$this</span>, <span class="keyword">__CLASS__</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">($currentPath)</span></span></div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;routes <span class="keyword">as</span> $routePath =&gt; $callback) &#123;</div><div class="line">        	<span class="keyword">if</span> ($routePath === $currentPath) &#123;</div><div class="line">            	$callback();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 这里返回的state是在callback内修改过的</span></div><div class="line">        header(<span class="string">'HTTP/1.1 '</span>.<span class="keyword">$this</span>.responseStatus);</div><div class="line">        header(<span class="string">'Content-type: '</span>.<span class="keyword">$this</span>.responseContentType);</div><div class="line">        header(<span class="string">'Content-length: '</span>.mb_strlen(<span class="keyword">$this</span>-&gt;responseBody));</div><div class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;responseBody;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 添加注册一个路由</span></div><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$app = <span class="keyword">new</span> App();</div><div class="line">$app-&gt;addRoute(<span class="string">'/users/josh'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// 因为这个route是bindTo到App class上的，所以这里直接访问$this修改 App 的内部state</span></div><div class="line">	<span class="keyword">$this</span>-&gt;responseContentType = <span class="string">'application/json;charset=utf8'</span>;</div><div class="line">    <span class="keyword">$this</span>-&gt;responseBody = <span class="string">'&#123;"name": "Josh"&#125;'</span>;</div><div class="line">&#125;);</div><div class="line">$app-&gt;dispatch(<span class="string">'/users/josh'</span>);</div></pre></td></tr></table></figure>
<h3 id="Zend-Opcache"><a href="#Zend-Opcache" class="headerlink" title="Zend Opcache"></a>Zend Opcache</h3><p>从PHP 5.5.0开始，PHP引入了内置的bytecode cache支持，叫做 <code>Zend OPcache</code>。PHP解释器在执行PHP脚本的时候，会首先把PHP代码编译为Zend Opcodes (machine-code instructions)，然后才会执行bytecode。在所有请求中，PHP解释器都需要这样处理所有的PHP文件，read/parse/compiles，然而我们可以通过把PHP文件预编为PHP bytecode来省略这个开销，这就是<code>Zend OPcache</code>。</p>
<p><code>Zend OPcache</code>的使用非常简单，在我们配置之后，它就会在内存中自动缓存precompiled PHP bytecode，在可用的情况就会直接执行这个PHP bytecode，而不需要再去编译PHP代码。</p>
<p>具体配置去google吧，有一点需要注意的是，如果同时配置了 Xdebug的话，在php.ini文件中，需要在Xdebug之前加载Zend OPcache extension扩展。</p>
<h3 id="Built-in-HTTP-server"><a href="#Built-in-HTTP-server" class="headerlink" title="Built-in HTTP server"></a>Built-in HTTP server</h3><p>PHP从5.4.0引入了内置的HTTP server，所以我们在不配置Apache或者nginx的情况下就直接预览PHP程序。</p>
<p><code>Remember, the PHP built-in server is a web server. It speaks HTTP, and it can serve static assets in addition to PHP files. It&#39;s a great way to write and preview HTML locally without installing MAMP, WAMP,  or a heavyweight web server.</code></p>
<p>要使用内置的HTTP server非常简单，在工程的根目录下，执行下面的命令即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php -S localhost:4000</div></pre></td></tr></table></figure></p>
<p>如果要让本地网络的其他设备访问PHP web server，我们可以这么启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php -S 0.0.0.0:4000</div></pre></td></tr></table></figure></p>
<p>如果我们希望通过 PHP INI 配置文件去做一些特殊配置，可以通过下面命令来启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php -S localhost:8000 -c app/config/php.ini</div></pre></td></tr></table></figure></p>
<p>我们也可以通过Router Scripts来实现一些特殊的路由需求，可以通过下面的命令启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php -S localhost:8000 router.php</div></pre></td></tr></table></figure>
<p>在PHP代码中，我们可以通过<code>php_sapi_name()</code>来判断：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">if</span> (php_sapi_name() === <span class="string">'cli-server'</span>) &#123;</div><div class="line">        <span class="comment">// PHP web server</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// Other web server</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Part-2-Good-Pratices"><a href="#Part-2-Good-Pratices" class="headerlink" title="Part 2. Good Pratices"></a>Part 2. Good Pratices</h1><h2 id="Standards"><a href="#Standards" class="headerlink" title="Standards"></a>Standards</h2><h3 id="PHP-FIG"><a href="#PHP-FIG" class="headerlink" title="PHP-FIG"></a>PHP-FIG</h3><p>PHP-FIG (PHP Framework Interop Group): <code>The PHP-FIG is a group of PHP framework representatives who, according to the PHP-FIG website, &quot;talk about the commonalities between our projects and find ways we can work together.&quot;</code></p>
<p>PHP-FIG是由很多不同PHP framework开发者组成的一个开放组织，他们提出的recommendations，不是标准或也不是要求，更像是best pratices的建议集合。不过，目前比较流行大多是PHP框架，比如Laravel或Symfony，都遵守了这些recommendations，所以这个感觉更像是Modern PHP事实上的标准，如果要使用PHP的很多工具和庞大的各种开源库，最好采用这个标准。</p>
<p><code>The PHP-FIG&#39;s mission is framework interoperability. And framework interoperability means working together via interfaces, autoloading, and style.</code><br>正如下面所说，PHP-FIG的使命就是不同framework之间的互通，让不同框架可以很容易结合在一起使用。而实现互通目前主要通过三个方面来入手：interfaces, autoloading, style：</p>
<ul>
<li>Interfaces: <code>Interfaces enable PHP developers to build, share, and use specialized components instead of monolithic frameworks</code>，基于interfaces，我们可以做到直接使用某个框架的某个组件，比如Laravel的HTTP的处理部分就是直接使用 Symfony Frameworks的 symfony/httpfoundation 组件，而不用把整个Symfony都集成到Laravel之内。</li>
<li>Autoloading: <code>PHP frameworks work together via autoloading. Autoloading is the process by which a PHP class is automatically located and loaded on-demand by the PHP interpreter during runtime</code>，在autoloading标准出来之前，PHP组件和框架都是基于 <code>\__autoload()或spl_autoload_register()</code> 方法来实现自己独特的autoloaders，所以我们要使用一个第三方组件的时候，需要首先去研究一下它的autoloaders的实现。</li>
<li>Style:  <code>PHP frameworks work together via code style.</code></li>
</ul>
<h3 id="PSR"><a href="#PSR" class="headerlink" title="PSR"></a>PSR</h3><p>PSR是 <code>PHP standards recommendation</code>的缩写，是PHP-FIG提出的recommendations文档，例如PSR-1，PSR-2等。每个PHP-FIG recommendation都是为了解决某个大多数PHP框架开发中常遇到的问题而提出的。</p>
<p>目前在PHP-FIG的官方网站上，<a href="http://www.php-fig.org/psr/" target="_blank" rel="external">http://www.php-fig.org/psr/</a> ，可以看到所有的recommendations，目前被采用的有下面几个：</p>
<p><img src="/img/PSR.png" alt=""></p>
<p>具体的PSR文档内容，可以参考官方网站，PSR-1/2/3/4 几个文档有中文翻译：</p>
<table>
<thead>
<tr>
<th>文档</th>
<th>原文</th>
<th>中文翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td>PSR-1 Basic Coding Standard</td>
<td><a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-1-basic-coding-standard.md" target="_blank" rel="external">https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-1-basic-coding-standard.md</a></td>
<td><a href="https://segmentfault.com/a/1190000002521577" target="_blank" rel="external">https://segmentfault.com/a/1190000002521577</a></td>
</tr>
<tr>
<td>PSR-2 Coding Style Guide</td>
<td><a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md" target="_blank" rel="external">https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md</a></td>
<td><a href="https://segmentfault.com/a/1190000002521620" target="_blank" rel="external">https://segmentfault.com/a/1190000002521620</a></td>
</tr>
<tr>
<td>PSR-3 Logger Interface</td>
<td><a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md" target="_blank" rel="external">https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md</a></td>
<td><a href="https://segmentfault.com/a/1190000002521644" target="_blank" rel="external">https://segmentfault.com/a/1190000002521644</a></td>
</tr>
<tr>
<td>PSR-4 AutoLoading Standard</td>
<td><a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader.md" target="_blank" rel="external">https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader.md</a></td>
<td><a href="https://segmentfault.com/a/1190000002521658" target="_blank" rel="external">https://segmentfault.com/a/1190000002521658</a></td>
</tr>
</tbody>
</table>
<h4 id="PSR-1-Basic-Coding-standard"><a href="#PSR-1-Basic-Coding-standard" class="headerlink" title="PSR-1 Basic Coding standard"></a>PSR-1 Basic Coding standard</h4><p><strong>PHP tags</strong> : 使用 &lt;?PHP ?&gt; or &lt;?= ?&gt;<br><strong>Encoding</strong>: 编码必须使用UTF-8<br><strong>Objective</strong>: 单个PHP文件只能定义symbols (a class, trait, function, constant, etc.) 或 perform某种有side effects的action (e.g., create output or manipulate data)。单个文件不能同时包含两种代码<br><strong>Autoloading</strong>: PHP namespaces和classes必须支持PSR-4 autoloader standard<br><strong>Class names</strong>: PHP类名必须是驼峰命名<br><strong>Constant names</strong>: 常量必须使用大写，然后以下划线分割，例如 GREAT_SCOTT<br><strong>Method names</strong>: PHP方法命名也必须采用驼峰命名，首字母小写</p>
<h4 id="PSR-2-Strict-Code-Style"><a href="#PSR-2-Strict-Code-Style" class="headerlink" title="PSR-2 Strict Code Style"></a>PSR-2 Strict Code Style</h4><p><strong>Implement PSR-1</strong> : 要求必须采用PSR-1<br><strong>Indentation</strong>: 采用4个空格字符作为缩进<br><strong>Files and lines</strong> :  必须使用Unix linefeed(LF)作为结尾；文件最后必须以空行作为结束；不能使用尾部 ?&gt; PHP tag；每行<em>尽量不要</em>超过80个字符，<em>最多不能</em>超过120个字符；每行结尾不能包含空格；<br><strong>Keywords</strong>: 所有的PHP关键字都必须小写<br><strong>Namespaces</strong>: 每个namespace声明后面都必须跟着一个空行；使用use来import or alias namespaces的时候，必须在use声明后面跟一个空行；<br><strong>Classes</strong>:  定义类时，开始的大括号(opening bracket)必须新起一行，结束的大括号(closing bracket)必须在类体定义后面新起一行；extents/implements关键字必须跟在类名定义的后面；例如：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">namespace</span> <span class="title">My</span>\<span class="title">App</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Administrator</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="comment">// Class definition body</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Methods</strong>: 方法定义的大括号规则与类定义类似，opening brackets和closing brackets都必须新起一行。<br><strong>Visibility</strong>: 对类中定义的全部property和method都必须声明可见性(visibility)，可见性是public, protected, private其中的一个；abstract / final 必须写在visibility之前；static必须写在visibility之后；<br><strong>Control structures</strong> :  所有的control structure keyword (if/elseif/else/switch/case/while/do while/for/foreach/try/catch)的后面都必须一个空字符；大括号的规则与class定义不同，opening brackets跟control structure keyword必须在同一行，而closing bracket必须另新一行；</p>
<p>我们可以通过IDE的格式化工具来让代码格式化，实现PSR-1和PSR-2的code style。我经常使用的工具PHPStorm就可以设置。还有一些其他工具，比如 <a href="http://cs.sensiolabs.org/" target="_blank" rel="external">PHP-CS-Fixer</a> 或 <a href="http://pear.php.net/manual/en/package.php.php-codesniffer.intro.php" target="_blank" rel="external">PHP Code Sniffer</a></p>
<h4 id="PSR-3-Logger-Interface"><a href="#PSR-3-Logger-Interface" class="headerlink" title="PSR-3 Logger Interface"></a>PSR-3 Logger Interface</h4><p><code>PSR-3 is an interface, and it prescribes methods that can be implemented by PHP logger components.</code></p>
<h4 id="PSR-4-Autoloaders"><a href="#PSR-4-Autoloaders" class="headerlink" title="PSR-4 Autoloaders"></a>PSR-4 Autoloaders</h4><p><code>An autoloader is a strategy for finding a PHP class, interface, or trait and loading it into the PHP interpreter on-demand at runtime. PHP components and frameworks that support the PSR-4 autoloader standard can be located by and loaded into the PHP interpreter with only one autoloader.</code></p>
<p>关于PSR-4，看官方文档之后感觉理解很困惑，本书的作者的解释就非常简洁：<br><code>The essence of PSR-4 is mapping a top-level namespaces prefix to a specific filesystem directory.</code>，简单来说，就是设定了一个namespaces前缀和某个特定的文件目录之间的映射关系，然后在这个namespace前缀之下如果还有更多的sub namespace，这些sub namespaces就会跟这个特定的目录下面的子目录一一映射起来。例如，\Oreilly\ModernPHP namespace与 src/ 物理路径一一映射，那么\Oreilly\ModernPHP\Chapter1对应的文件夹就是src/Chapter1，而\Oreilly\ModernPHP\Chapter1\Example类对应的文件路径就是src/Chapter1/Example.php文件。</p>
<p><code>PSR-4 lets you map a namespace prefix to a filesystem directory. The namespace prefix can be one top-level namespace. The namespace prefix can also be a top-level namespace and any number of subnamespaces. It&#39;s quite flexible.</code></p>
<h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><h3 id="Components-1"><a href="#Components-1" class="headerlink" title="Components"></a>Components</h3><p><code>Modern PHP is less about monolithic framework and more about composing solutions from specialized and interoperable components.</code></p>
<p><strong>What Are Components?</strong>： <code>A component is a bundle of code that helps solve a specific problem in your PHP application.</code></p>
<p><strong>框架与Components</strong>：如果我们正在创建一个小项目，可以直接使用一些PHP Components集合来解决问题；如果我们正在进行一个多人合作开发的大项目，我们可以通过使用一个Framework；但这都不是绝对的，应该根据具体问题来解决。</p>
<p><strong>Packagist</strong>：跟其他语言的包管理机制一样，例如Maven，也有一个网站 <a href="https://packagist.org/" target="_blank" rel="external">https://packagist.org/</a>  让我们搜索我们需要的PHP Components的相关信息。总所周知的原因，Packagist在国内很不稳定，可以使用国内的全量镜像来代替，<a href="http://www.phpcomposer.com/" target="_blank" rel="external">http://www.phpcomposer.com/</a> 。</p>
<h3 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h3><p><code>Composer is a dependency manager for PHP components taht runs on the command line</code>，跟其他现代语言一样，PHP使用Composer来做依赖管理，类似的有iOS中的Cocoapods，Android中的Maven/gradle，前端的npm，ruby的gem，这些工具可以大大简化我们管理第三方库的成本。于是，当我们在Packagist上面找到我们需要的Components之后，就可以通过Composer来使用这个库。</p>
<p>当我们使用Composer来添加第三方Component的时候，Composer除了会自动帮我们下载需要的PHP Components之外，还会自动帮我们创建一个符合PSR-4的Autoloader。</p>
<p>跟Cocoapods类似，Cocoapods使用Podfile来指定需要依赖的第三方库，以及保存有当前使用的具体的第三方库的版本号。所以我们需要把这两个文件都加入到版本控制中进行管理，确保不同成员/CI/开发环境等不同地方大家使用第三方库版本的一致性。对应Composer中的文件就是 composer.json以及composer.lock。这里需要注意的是composer install 和 composer update 命令的差别：</p>
<ul>
<li>composer install，不会安装比composer.lock中列出的更高版本的Components；</li>
<li>composer update，会更新你的components到最新的稳定版，同时也会更新composer.lock文件为最新的PHP components版本号。</li>
</ul>
<h3 id="Semantic-Versioning"><a href="#Semantic-Versioning" class="headerlink" title="Semantic Versioning"></a>Semantic Versioning</h3><p>Modern PHP Components 使用 Semantic Versioning scheme，同时包含了用小数点(.)分隔的三个数字，比如 1.13.2。同时，这个也是很多其他语言开源库的版本规则，对这个一直比较好奇，终于在Modern PHP中看到了相应的解释。</p>
<ul>
<li>major release number：第一个数字是major release number，只有当PHP Component发生不再向前兼容的更新时，才需要增加这个版本号。</li>
<li>minor release number：第二个数字是minor release number，当PHP Component发生一些小的功能更新，并且没有破坏版本兼容时，增加这个版本号。</li>
<li>patch release number：最后一个数字是patch release number，当发生版本兼容的bug修复的时候，增加这个版本号。</li>
</ul>
<h3 id="Create-PHP-Components"><a href="#Create-PHP-Components" class="headerlink" title="Create PHP Components"></a>Create PHP Components</h3><p>这部分跟iOS创建自己的spec非常相似，并不是非常复杂的问题，参考书或者官方文档很容易就能发布</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://avatar.csdn.net/4/B/6/1_lihei12345.jpg"
               alt="lihei12345" />
          <p class="site-author-name" itemprop="name">lihei12345</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lihei12345</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'lihei12345githubio';
      var disqus_identifier = 'index.html';
      var disqus_title = "";
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  




  
  

  

  

  

</body>
</html>
